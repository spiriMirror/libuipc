namespace uipc::backend::cuda::analyticalBarrier
{
namespace details
{
    template <typename T>
    MUDA_GENERIC void pFpx_pe(
        T d, T x11, T x12, T x13, T x21, T x22, T x23, T x31, T x32, T x33, T result[9][4])
    {
        T t18;
        T t19;
        T t20;
        T t21;
        T t22;
        T t23;
        T t24;
        T t25;
        T t26;
        T t43;
        T t44;
        T t45;
        T t46;
        T t47;
        T t51;
        T t54;
        T t55;
        T t56;
        T t8;
        /* pFpx_pe */
        /*     RESULT = pFpx_pe(D,X11,X12,X13,X21,X22,X23,X31,X32,X33) */
        /*     This function was generated by the Symbolic Math Toolbox version 9.0.
     */
        /*     30-Apr-2022 18:45:25 */
        t8           = 1.0 / d;
        t18          = -x21 + x11;
        t19          = -x22 + x12;
        t20          = -x23 + x13;
        t21          = -x31 + x11;
        t22          = -x32 + x12;
        t23          = -x33 + x13;
        t24          = -x31 + x21;
        t25          = -x32 + x22;
        t26          = -x33 + x23;
        t43          = 1.0 / ((t24 * t24 + t25 * t25) + t26 * t26);
        t45          = t18 * t22 + -(t19 * t21);
        t46          = t18 * t23 + -(t20 * t21);
        t47          = t19 * t23 + -(t20 * t22);
        t44          = t43 * t43;
        t51          = (t45 * t45 + t46 * t46) + t47 * t47;
        t54          = (x21 * 2.0 + -(x31 * 2.0)) * t44 * t51;
        t55          = (x22 * 2.0 + -(x32 * 2.0)) * t44 * t51;
        t56          = (x23 * 2.0 + -(x33 * 2.0)) * t44 * t51;
        t44          = 1.0 / sqrt(t43 * t51);
        result[0][0] = 0.0;
        result[0][1] = 0.0;
        result[0][2] = 0.0;
        t51          = t8 * t43 * t44;
        result[0][3] = t51 * (t25 * t45 * 2.0 + t26 * t46 * 2.0) / 2.0;
        result[1][0] = 0.0;
        result[1][1] = 0.0;
        result[1][2] = 0.0;
        result[1][3] = t51 * (t24 * t45 * 2.0 - t26 * t47 * 2.0) * -0.5;
        result[2][0] = 0.0;
        result[2][1] = 0.0;
        result[2][2] = 0.0;
        result[2][3] = t51 * (t24 * t46 * 2.0 + t25 * t47 * 2.0) * -0.5;
        result[3][0] = 0.0;
        result[3][1] = 0.0;
        result[3][2] = 0.0;
        t51          = t8 * t44;
        result[3][3] = t51 * (t54 + t43 * (t22 * t45 * 2.0 + t23 * t46 * 2.0)) * -0.5;
        result[4][0] = 0.0;
        result[4][1] = 0.0;
        result[4][2] = 0.0;
        result[4][3] = t51 * (t55 - t43 * (t21 * t45 * 2.0 - t23 * t47 * 2.0)) * -0.5;
        result[5][0] = 0.0;
        result[5][1] = 0.0;
        result[5][2] = 0.0;
        result[5][3] = t51 * (t56 - t43 * (t21 * t46 * 2.0 + t22 * t47 * 2.0)) * -0.5;
        result[6][0] = 0.0;
        result[6][1] = 0.0;
        result[6][2] = 0.0;
        result[6][3] = t51 * (t54 + t43 * (t19 * t45 * 2.0 + t20 * t46 * 2.0)) / 2.0;
        result[7][0] = 0.0;
        result[7][1] = 0.0;
        result[7][2] = 0.0;
        result[7][3] = t51 * (t55 - t43 * (t18 * t45 * 2.0 - t20 * t47 * 2.0)) / 2.0;
        result[8][0] = 0.0;
        result[8][1] = 0.0;
        result[8][2] = 0.0;
        result[8][3] = t51 * (t56 - t43 * (t18 * t46 * 2.0 + t19 * t47 * 2.0)) / 2.0;
    }
}  // namespace details

template <class T>
MUDA_GENERIC void analytical_point_edge_pFpx(const Eigen::Vector<T, 3>& p,
                                             const Eigen::Vector<T, 3>& e1,
                                             const Eigen::Vector<T, 3>& e2,
                                             T d_hatSqrt,
                                             T result[9][4])
{
    details::pFpx_pe(d_hatSqrt, p[0], p[1], p[2], e1[0], e1[1], e1[2], e2[0], e2[1], e2[2], result);
}

}  // namespace uipc::backend::cuda::analyticalBarrier