namespace uipc::backend::cuda::analyticalBarrier
{
namespace details
{
    template <typename T>
    MUDA_GENERIC void pFpx_pp(T d, T x11, T x12, T x13, T x21, T x22, T x23, T result[6])
    {
        T t25;
        T t26;
        T t27;
        T t8;
        /* pFpx_pp */
        /*     RESULT = pFpx_pp(D,X11,X12,X13,X21,X22,X23) */
        /*     This function was generated by the Symbolic Math Toolbox version 9.0.
     */
        /*     30-Apr-2022 19:00:49 */
        t8        = 1.0 / d;
        t25       = -x21 + x11;
        t26       = -x22 + x12;
        t27       = -x23 + x13;
        t25       = 1.0 / sqrt((t25 * t25 + t26 * t26) + t27 * t27);
        t26       = t8 * (x11 * 2.0 + -(x21 * 2.0)) * t25 / 2.0;
        t27       = t8 * (x12 * 2.0 + -(x22 * 2.0)) * t25 / 2.0;
        t25       = t8 * (x13 * 2.0 + -(x23 * 2.0)) * t25 / 2.0;
        result[0] = t26;
        result[1] = t27;
        result[2] = t25;
        result[3] = -t26;
        result[4] = -t27;
        result[5] = -t25;
    }
}  // namespace details

template <class T>
MUDA_GENERIC void analytical_point_point_pFpx(const Eigen::Vector<T, 3>& p0,
                                              const Eigen::Vector<T, 3>& p1,
                                              T d_hatSqrt,
                                              T result[6])
{
    details::pFpx_pp(d_hatSqrt, p0[0], p0[1], p0[2], p1[0], p1[1], p1[2], result);
}

}  // namespace uipc::backend::cuda::analyticalBarrier