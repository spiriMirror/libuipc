// Affine Body Prismatic Joint Constraint
// Description: Symbolic expressions for prismatic joint constraint between two affine bodies.

template <typename T>
__host__ __device__ void DeltaTheta(T& R, const Eigen::Vector<T,9>& F, const Eigen::Vector<T,9>& F_t)
{
/*****************************************************************************************************************************
Function generated by SymEigen.py 
Author: MuGdxy
GitHub: https://github.com/MuGdxy/SymEigen
E-Mail: lxy819469559@gmail.com
******************************************************************************************************************************
Symbol Name Mapping:
F:
    -> {}
    -> Matrix([[F(0)], [F(1)], [F(2)], [F(3)], [F(4)], [F(5)], [F(6)], [F(7)], [F(8)]])
F_t:
    -> {}
    -> Matrix([[F_t(0)], [F_t(1)], [F_t(2)], [F_t(3)], [F_t(4)], [F_t(5)], [F_t(6)], [F_t(7)], [F_t(8)]])
*****************************************************************************************************************************/
/* Sub Exprs */
auto x0 = (1.0/2.0)*F(0);
auto x1 = (1.0/2.0)*F(1);
auto x2 = (1.0/2.0)*F(2);
auto x3 = (1.0/2.0)*F_t(0);
auto x4 = (1.0/2.0)*F_t(1);
auto x5 = (1.0/2.0)*F_t(2);
/* Simplified Expr */
R = F(3)*x0 + F(4)*x1 + F(5)*x2 + F(6)*x0 + F(7)*x1 + F(8)*x2 - F_t(3)*x3 - F_t(4)*x4 - F_t(5)*x5 - F_t(6)*x3 - F_t(7)*x4 - F_t(8)*x5;
}
template <typename T>
__host__ __device__ void dDeltaTheta_dF(Eigen::Vector<T,9>& R, const Eigen::Vector<T,9>& F, const Eigen::Vector<T,9>& F_t)
{
/*****************************************************************************************************************************
Function generated by SymEigen.py 
Author: MuGdxy
GitHub: https://github.com/MuGdxy/SymEigen
E-Mail: lxy819469559@gmail.com
******************************************************************************************************************************
Symbol Name Mapping:
F:
    -> {}
    -> Matrix([[F(0)], [F(1)], [F(2)], [F(3)], [F(4)], [F(5)], [F(6)], [F(7)], [F(8)]])
F_t:
    -> {}
    -> Matrix([[F_t(0)], [F_t(1)], [F_t(2)], [F_t(3)], [F_t(4)], [F_t(5)], [F_t(6)], [F_t(7)], [F_t(8)]])
*****************************************************************************************************************************/
/* Sub Exprs */
auto x0 = (1.0/2.0)*F(0);
auto x1 = (1.0/2.0)*F(1);
auto x2 = (1.0/2.0)*F(2);
/* Simplified Expr */
R(0) = (1.0/2.0)*F(3) + (1.0/2.0)*F(6);
R(1) = (1.0/2.0)*F(4) + (1.0/2.0)*F(7);
R(2) = (1.0/2.0)*F(5) + (1.0/2.0)*F(8);
R(3) = x0;
R(4) = x1;
R(5) = x2;
R(6) = x0;
R(7) = x1;
R(8) = x2;
}
template <typename T>
__host__ __device__ void ddDeltaTheta_ddF(Eigen::Matrix<T,9,9>& R, const Eigen::Vector<T,9>& F, const Eigen::Vector<T,9>& F_t)
{
/*****************************************************************************************************************************
Function generated by SymEigen.py 
Author: MuGdxy
GitHub: https://github.com/MuGdxy/SymEigen
E-Mail: lxy819469559@gmail.com
******************************************************************************************************************************
Symbol Name Mapping:
F:
    -> {}
    -> Matrix([[F(0)], [F(1)], [F(2)], [F(3)], [F(4)], [F(5)], [F(6)], [F(7)], [F(8)]])
F_t:
    -> {}
    -> Matrix([[F_t(0)], [F_t(1)], [F_t(2)], [F_t(3)], [F_t(4)], [F_t(5)], [F_t(6)], [F_t(7)], [F_t(8)]])
*****************************************************************************************************************************/
/* Sub Exprs */
/* Simplified Expr */
R(0,0) = 0;
R(0,1) = 0;
R(0,2) = 0;
R(0,3) = 1.0/2.0;
R(0,4) = 0;
R(0,5) = 0;
R(0,6) = 1.0/2.0;
R(0,7) = 0;
R(0,8) = 0;
R(1,0) = 0;
R(1,1) = 0;
R(1,2) = 0;
R(1,3) = 0;
R(1,4) = 1.0/2.0;
R(1,5) = 0;
R(1,6) = 0;
R(1,7) = 1.0/2.0;
R(1,8) = 0;
R(2,0) = 0;
R(2,1) = 0;
R(2,2) = 0;
R(2,3) = 0;
R(2,4) = 0;
R(2,5) = 1.0/2.0;
R(2,6) = 0;
R(2,7) = 0;
R(2,8) = 1.0/2.0;
R(3,0) = 1.0/2.0;
R(3,1) = 0;
R(3,2) = 0;
R(3,3) = 0;
R(3,4) = 0;
R(3,5) = 0;
R(3,6) = 0;
R(3,7) = 0;
R(3,8) = 0;
R(4,0) = 0;
R(4,1) = 1.0/2.0;
R(4,2) = 0;
R(4,3) = 0;
R(4,4) = 0;
R(4,5) = 0;
R(4,6) = 0;
R(4,7) = 0;
R(4,8) = 0;
R(5,0) = 0;
R(5,1) = 0;
R(5,2) = 1.0/2.0;
R(5,3) = 0;
R(5,4) = 0;
R(5,5) = 0;
R(5,6) = 0;
R(5,7) = 0;
R(5,8) = 0;
R(6,0) = 1.0/2.0;
R(6,1) = 0;
R(6,2) = 0;
R(6,3) = 0;
R(6,4) = 0;
R(6,5) = 0;
R(6,6) = 0;
R(6,7) = 0;
R(6,8) = 0;
R(7,0) = 0;
R(7,1) = 1.0/2.0;
R(7,2) = 0;
R(7,3) = 0;
R(7,4) = 0;
R(7,5) = 0;
R(7,6) = 0;
R(7,7) = 0;
R(7,8) = 0;
R(8,0) = 0;
R(8,1) = 0;
R(8,2) = 1.0/2.0;
R(8,3) = 0;
R(8,4) = 0;
R(8,5) = 0;
R(8,6) = 0;
R(8,7) = 0;
R(8,8) = 0;
}
